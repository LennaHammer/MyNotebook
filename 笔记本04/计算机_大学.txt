# 大学计算机的典型问题

选几个有代表性的问题，不要列举知识点

## 算法

### 1 分析

$ 1<\ln n<n<n ln n< n^2 < n^3 < 2^n < n! < n^n $

由小到大：1,log(n),n,n*log(n),n^2
数学归纳法（先从1，2的特例开始，取一些极端的分布情况）
最多用最少做，最少用最多做，抽屉原理
有时就用特殊值，具体的值，极端的值

### 2 链表、数组
#### 链表
+ 逆置链表（原地）
+ 倒数第k个元素（双指针）
+ 共同后缀（先求两者的长度）
+ 去重（用hash）
+ 删除元素

#### 数组
+ 旋转数组（三次逆置）
+ 寻找主元素（一趟）

### 3 栈、队列
#### 栈
出栈序列
栈容量
栈底插入？
#### 循环队列
数组存储，区分空和满
#### 中缀表达式
运算符栈，优先级

### 4 树
#### 树的节点数
节点=边数+1
二叉树：叶结点为度为2的节点数加1
#### 完全二叉树
从0，1编号
节点深度
有最多2^k-1节点（等比数列），深度[log2(n)]+1
从0编号则左2i+1右2i+2父(i-1)/2
#### 二叉树的遍历
先序NLR，中序LNR，后序LRN（按根节点）
线索二叉树，按照遍历顺序线索化
层次遍历（广度优先）
得到遍历序列
中序遍历为出栈序列？？
##### 非递归实现 ★★
用栈
先序（深度优先）
s.push(root)
while s:
    p = s.pop()
    yield p
    if p.right:s.push(p.right)
    if p.left: s.push(p.left)
中序 ★★
p = root
while s or p:
    if p:
        s.push(p)
        p=p.left
    else:
        p = s.pop()
        yield p
        p = p.right
后序：
p=root
while
    while p:
        s.push(p)
        p = p.left
    q= None
    while s
        p= s.pop
        if p.right=q
            yield p
            q=p
        else
            s.push(p)
            p = p.right
            break
        if not s: break

#### 二叉排序树
插入
删除（移大于它的元素补）
##### 平衡AVL二叉树 ★★
先按二叉排序树插入，删除（移动大于它的元素）
然后从下往上找节点的平衡因子
一次旋转动三个节点（它们的子树对应移动）
LR型先左旋再右旋，单独的两步

####  二叉树表示森林 ★
左：第一个孩子（下一层）
右：兄弟（有共同的父节点，同层）

同层节点的左子节点构成链表

#### 广义表
可以表示链表，二叉树（进而表示森林↑）
注意嵌套，取tail时不是取元素（是移除元素）
#### AVL树、huffman树
先按
旋转
 LL/LR
 **** 哈夫曼树
 通过权值合并（最小的相加）构建，只有一个子树非终端节点
 
 
 
### 5 图
#### 度的关系
有向完全图边数=n(n-1)，无向再一半
度（出，入）：边数
最少需要考虑最多的情况（抽屉原理）
连通：任意两点存在路径

#### 表示
矩阵行表示起点列表示终点
压缩储存（对角线为0）
邻接表
#### 图的遍历
深度，广度优先
时间复杂度
#### 最小生成树
无环，总边长最小
会导致环的边/点不选
prim 
依次选边最短的相邻节点
相邻边中选择（加入）最短的边
时间复杂度：V^2 ★
kruskal 
选最短的边，且不构成环
复杂度：ElogE ★
#### 单源最短路径/迪杰斯特拉 ★★
分解步骤（每趟）
+ 初始距离无穷大，原点为0
+ 每趟选择出到原点距离最短的点，并更新相邻节点的距离（和前驱）
+ 第一趟选出原点，每趟记录所有选出的节点
求解过程更新
+ 选择的点，每个点的距离，已选出的点
O(V^2)

另一个 Floyd 算法，类比矩阵乘法（取最小值），O(n^3)
#### 拓扑排序
不唯一
每趟移除入度为0的点
逆深度优先遍历
#### 关键路径/AOE网 ★

等价于找最长路径

节点表示事件，边表示活动（按起点算）。

通过计算节点来寻找边。

+ 计算节点的最早（距原点的最长路径长度），最迟（从最长距离长度逆推，距汇点的最短路径长度）发生时间
+ 点的差等于边长则该边构成关键路径（即边的两个时刻相等）

注意：两点之间会有一条或多条关键路径


### 6 查找
#### 二分查找
判定树
查找长度：比较次数
两个数组的中位数（总长奇偶）
平均查找长度（成功，失败，算比较次数）
注意终止条件能达到
#### B 树 ★
是多叉排序树
m阶
+ 至多m棵子树
+ 非叶节点至少ceil(m/2)棵（根是2，左右，一个关键字）子树
+ 关键字数为子树个数-1
调整：
+ 插入（分裂，给父节点一个关键字，从下往上）
+ 删除 1.直接删，子树合并 2.借兄弟节点（换来父节点），或合并（并入一个父节点）
B+树：最下层的叶结点表示关键字（有序），中间结点为子树的最大值，关键字数为子树数

#### 哈希表 ★
取余数，作为下标
冲突处理：线性探测，二次探测（1,-1,4,-4），链表法
平均查找长度（
+ 成功算已有元素，
+ 失败按模算每个桶的都失败一次，
+ 注意要对应冲突处理的策略）！！
比较次数：成功时至少1次，失败时至少一次

#### KMP ★
线性在s中找t
失败时利用t自身重复的前缀（看不包括自己的前缀，跳到这一个要用来比较的下标）
不断地比较s下一个字符

#### 平均查找长度
按比较次数，最少一次
每个元素等可能（和除以个数，求平均）
成功，已有元素
失败，所有元素



### 7 排序
每趟中数组的变化
已经有序的情况
#### 冒泡排序
代码两层循环
每趟能确定一个最大元素位置
相等元素排序中位置关系不变
#### 插入排序
##### 直接插入排序 ★
依次（从前往后）把元素插入（从后往前）前面有序序列中
直接插入排序可以是稳定的！！稳定！！
##### 折半插入排序
##### 希尔排序
直插排序子序列，步长缩小至1
#### 选择排序
##### 简单选择排序
选出最大/先元素于依次放在（交换）一端
##### 堆排序 ★
满足不等关系
完全二叉树
调整：从上往下，3选1
操作：插入（尾，和父比较），取出（用尾代替头，往下和两个子比较），建堆（从下往上合并堆，不断使用调整）
先建堆再选择排序
+ 如取出最大元素放在末尾，对换，末尾元素放在堆顶调整
#### 快速排序 ★
划分+递归
代码：两种。
#### 归并排序
最好最坏情况（比较次数，一个为空时则不用比较）
结合哈夫曼树归并
#### 基数排序
#### 外部排序
#### 复杂度
冒泡 n^2
快排 时间nlog n 空间log n 最坏 n*n
#### 稳定性
稳定的：直接插入、折半插入、冒泡、归并排序、基数排序

### 8 补充算法
回溯法，八皇后
非递归求幂
动态规划序列
主元素



## 二 组成原理

### 1 CPU参数 ★★
+ 主频：每秒的时钟周期数
1kHz=1000Hz
主频的倒数是时钟周期（每个时钟周期的秒数）
+ CPI：每条指令的时钟周期数
CPI：周期数/一条指令
主频/CPI=每秒的指令数
带宽:每秒的传输的数据=总线宽度*主频
时钟周期=主频的倒数

MIPS 百万指令每秒
MFLOPS 百万浮点运算每秒

### 2 数
#### 进制转换
##### 十进制转二进制
##### 负数补码
取反加一，相反数相加为0
加法直接计算（十六进制补上高位也可以）
位数扩展负数高位补1
正负的范围-128到127
不看符号位全1（2^k-1）全0时
十六进制补码转十进制：
##### 浮点数和二进制
单精度32位的规格化数
+ 1：符号
+ 8：阶码减去127（全0全1保留）
+ 23：从省略的1.开始
计算加法时对阶取大阶
大小直接按位比较
#### 运算
加减溢出：双符号位，判断两个进位（符号和最大数位），一致则未溢出，和被加数符号比较。表示范围，补码都是按加法运算
浮点对阶：取大阶
除以2是右移
#### 编码
小端:按字节先低后高
边界对齐:按类型长度，结构的数组
海明码
CRC：多项式除法（列竖式），模二运算（无进位借位）。末尾补零后再算，余数比除数少一位。

### 3 储存
2KB=2^10B
1MB=2^20B
1B=8b 注意需要时转换
按字节编址，位数对应空间大小
存取时间，储存周期（间隔），数据传输率（=宽度/储存周期）
DRAM地址分行列，地址线减半
n体交叉（随后的传输与读取重叠）流水
#### 字/位扩展
位：数据线，按位分片
字：地址线，高位用于片选，低位全连
#### 缓存Cache ★★
Cache命中率（第一次肯定不命中）
2路组相联（组数减半，组间直接映射，组内全相联映射）组内块号可以和标志位合并。
让相邻的块在不同的组
注意：块数，每块的大小，和偏移量位数
##### 地址变换
映射：按内存地址读取

地址：tag+块号（位数取决于组数）+offset
cache行：有效位（1bit）+tag（标记）+数据块（位数取决于固定的块大小），组号不用含了

取块号可以位移和按位与，也可以除以（块的大小）再取模（组数）
C地址：块号+偏移
全相联映射没有组号，页号是tag
组数决定组号占的位数

##### 替换算法
fifo
lru
opt
##### 写策略
回写，直写
回写法加上一致性维护位
#### 虚拟内存★★
Cache,TLB,Page
C和T在CPU，P在内存
Cache 是对内存的缓存，提升速度
Page 是对硬盘的缓存，扩大空间
##### 分页
页表（虚拟地址到物理地址（内存），有效位，会不命中）
页面大小固定（容量，偏移量（页内地址）位数），根据虚拟地址容量可得页表项数
页表在内存中，缺页则IO
虚拟地址（虚页号+页内地址），物理地址（页框号+页内地址）
表示的空间大小等于2^位数。
全相联映射没有分组
##### 快表
TLB是Page的缓存，减少读内存
内容是页表部分，每组是有效位+标记（去掉低位的组号）+页框号
按Cache分组
##### 命中率
指标
根据替换策略和读取内存次数

#### 操作系统原理
和页表/虚拟内存一章有交错的内容。

### 4 指令
#### 编码
按位，编码，混合（组合时有留空）
2^位数=个数
编址字长（按字节编址，按字，比较地址和指令长度）
指令：操作码+寻址方式+形式地址+（操作数_2）
#### 寻址
+ 隐含
+ 立即
+ 直接：按操作数（是内存地址）读取数据
+ 间接：按内存中读取的地址读取
+ 寄存器
+ 相对（跳转）
+ 基址（分段）
+ 变址（数组），寄存器和形式地址相加
+ 堆栈（Push/Pop）
#### 汇编语录/机器码
标志寄存器：借位，零，符号，溢出
比较运算：等价于相减
跳转：计算相对地址时PC已经自增（取指令的全部数据）过了，偏移量可能会要乘以系数
运算区分无符号和有符号数
数据通路示意图：加法器，位移器（按运算流程）
数据在指令中，寄存器，内存中
数组的读取（每个元素大小，下标对应地址）
和c代码对照
#### 流水冲突（移到后面微程序章节中）★
RISC
5段：取指，读寄存器，执行，访问内存，写寄存器
1 寄存器的读者冲突（前面的指令要写，自己的第二步要读，阻塞在这一步上）
3 前一天读寄存器暂停，下一条取指也暂定
2 分支跳转：等指令完成
流水节约所用的时钟周期（重叠一部分）
画示意图


### 5 微程序

寄存器 pc ar ir
+ PC 程序计数，是可见的
+ IR 指令寄存器
+ MAR 地址
+ MDR 数据
ALU 运算
每一步一个时钟周期（节拍）
读写内存：m(ar)->dr, dr->m(ar)，其中ar是隐含的（前一步指定好）
CISC
#### 取指
指令从内存取到IR
1 PC->MAR
2 M->MDR，PC++
3 MDR->IR
pc自增指令长度
阶段：取址，间址，执行，中断
#### 执行
取指后，读（所有）操作数送入寄存器（比如立即数，直接寻址读内存），运算，写内存
跳转则修改PC
#### 读内存
按地址读取到寄存器
1 R1->MAR
2 M->MDR
3 MDR->A 
写 store
1 A->MDR
2 R2->MAR
3 MDR->M
#### 控制信号，数据通路
指令编码可以一组相容的微指令一起
控制信号：寄存器的数据同时的一组 in,out，每个节拍
数据通路：连线，和总线表示数据流动，元件接受控制信号
#### 流水线

### 6 总线 ★
#### 传输率
总线频率：时钟周期（每个时钟周期花费的时间，单位秒）的倒数，每秒的次数，1MHz=10^6Hz
总线宽度：数据总线（特指）位数，单位比特
总线带宽=(总线宽度/8)*总线频率 ★
总线带宽：传输率，每个秒传输的数据量（字节）
#### 
USB 通用串行串行

### 7 I/O
#### 磁盘
RAID
转速：找扇区，半圈
传输速率：读取数据，也可用转速算
寻道：
存取时间，分别单独相加
#### 中断★★
占CPU时间可以用时钟周期数算

内（CPU），外（键盘）
中断响应：两步
1 中断隐指令（硬件实现）：关中断，保存断点（PC）
2 中断服务程序：处理前后保存和恢复现场，开中断，返回。多级中断在处理前开（后关）中断。
##### 中断优先级，屏蔽字
高的可以抢占低的，作图（任务结束，任务被抢占）
屏蔽比自己优先级低的，设为1
#### DMA
计算：每秒产生的次数，每次的时钟周期，每秒的总开销，占CPU时间


## 三 操作系统
### 1 概述
函数调用直接保存下一个指令地址
系统调用
### 2 进程
#### 进程调度
状态：运行、就绪、阻塞
调度
高响应比优先：
时间片轮转：
IO多的给高优先级
计算：平均周转时间，提交到结束★

#### 进程同步、信号量 ★
表示资源数：负数表示等待的线程数
信号量是比较底层的实现，往上有一些抽象的易用的概念
##### 同步问题 ★★★★★
+ 临界区：S=1，P ... V 表示操作数据结构时互斥，表示多个进程只允许一个执行，也可表示资源数

+ 前驱关系 S=0，线程1尾 V -> 线程2头 P . 可以1对多（分支语句加两个不同的后继），模拟描述的现实问题

+ 生产消费，同步队列，一个缓冲区 S_full=0,S_empty=N，此时缓冲区为空，生产者有空时添加（P_empty,写,V_full），消费者有元素时移除（P_full,取,V_empty，五句是个整体），两对PV操作的信号量对调，多个资源时表示资源增减。存取步骤可以用临界区，可以为空。


+ 读者写者
写者：
P(w)
P(rw)    <------这个是写者的锁
...
V(rw)
V(w)
读者：
P(w)
P(m)
if count==0: P(rw)
count++
V(m)
V(w)
...
P(m)
count--
if count==0: V(rw)
V(m)
其中：w的目的是为了写者优先，否则不需要。也有读者对称的情况。

+ 哲学家：需申请多个资源
  + 取先左后右，放先右后左，对称
  
理发师，银行排队
椅子和柜台是两个资源，且有个数。
#### 死锁
##### 死锁避免，银行家算法★
安全状态：能找到安全序列（依次执行并释放资源）
每个进程总共需要/已分配，剩余资源数
检测分配请求后能否找到安全序列，决定是否分配
目的是分配请求时避免死锁。

##### 死锁检测，分配图
判断是否已经在死锁状态（必然无法继续运行）
箭头表示资源已分配，和进程仍在请求的
检测是否存在化简的执行序列，能满足请求则释放资源

### 3 内存
#### 内存分配算法
首次，最佳（最小），最差（最大）
#### 虚拟内存
二级页表：减少页表占用内存，页号分为外层页号和外层页内地址
页表项也存放在若干页中，分页管理页表项
页内偏移位数~页大小（2的指数）
位数占字节数（除以8）
页表项按页号顺序排列
缺页：先访问快表，没有则页表，再没有则触发缺页中断，此时再访问快表，最后用得到的物理访问主存
缺页中断会淘汰出页面
计算：平均存取时间，三种情况考虑快表命中率和缺页率
##### 分页
页表项：页号，块号
##### 页面置换
页框（Page Frame）
fifo：先进先出
lru：链表法（把访问的移到头，淘汰尾），计数法（访问时更新时刻，淘汰旧的）
clock：（当前指向的为0时淘汰，载入或访问时为1，路过减1，一致按环查找到可以替换出的页）
改进clock:未使用且未修改。
空闲列表，驻留集，belady，抖动
### 4 文件
open/read
连续，链接，索引
位图法（位等于字节数乘以8）
#### 文件系统
文件控制块
磁盘数据块（大小）
索引表（一项对应一个磁盘块）
读写算访问两次磁盘块
块号位数~寻址范围
混合索引：间接地址，用索引指向磁盘块存放索引，总空间累加
inode
#### 磁盘
##### 访问时间 ★
参数，转速
寻道
旋转
传输
半圈？
##### 磁盘调度
先来
最短
scan电梯：有移动方向，来回移动
循环扫描：单向移动
移动的道数
0磁道在外侧
##### 文件系统
多级索引：指向储存索引的磁盘块
块大小
FAT
Unix的inode
位图法，空闲链表法
### 5 I/O

io层次：用户程序->（系统调用->驱动）->中断
缓冲区：单双，计算
有重叠的任务（处理数据，双缓冲）时，最后一个任务没有后继，要多算部分
传输率/带宽=频率*宽度




## 四 网络

### 1 概念
OSI七层、TCP/IP
五层：物理层（比特流），数据链路层（mac帧，网桥），网络层（ip，路由），传输层（tcp/udp）（会话层，表示层），应用层（http）

### 2 物理层
差分曼彻斯特编码：跳跃方向相同表示1，相反表示0
数据传输率=波特率*log2(离散值个数)
极限数据传输率=2*频率（信道带宽）*log2(离散值个数)
=信道带宽*log2(1+S/N) 其中10 log10(S/N)为信噪比
有噪声，无噪声
#### 储存转发
单位bps：位，10进制进位，字节转化为位再运算
+ 发送时延=报文长度/报文发送速率
+ 传播时延=线路长度/信号速度
+ 处理时延
总时间为发送时间加传播时间
分组交换时发送和传播有重叠，除了等最后一个要传播完毕
字节换算成位
发送到收到确认：双向传播时延加两个发送时延
#### 物理层设备
中继器
集线器（直接转发）


### 3 数据链路层
连续5个1填充0，否则表示结束
CRC：补k-1（比除数少1）个零，然后多项式除法（且无借位），余数代替补的零。
CDMA：向量点积
#### 滑动窗口
后退N帧，累计确认
传输速率=窗口大小/双向时延★★，即吞吐量
同时传播的帧数=双向时延（加两个发送时间）/发送1帧的时间
#### 碰撞检测 CSMA/CD 
2r
最小帧长=往返传播时延*数据传输速度★★
注意：是发送的速率，不是传播的速率（这个已经用来决定传播时延了）！！也可以用来求窗口大小。
2r=2 距离/信号速度
发送时间=帧长/数据传输率  <-- 传输速率不是信号速率
传输速率和帧长单位一致（位）
小于最小帧长的为遇到碰撞停止发送的无效帧
传输速率是指发送时延
单位字节先转成位再运算
计算有效率，利用率：分子发送时延，分母加上传播和确认的时延★
目的是检测发送时是否发生冲突
CA 无线局域网碰撞避免，需要确认帧
最小帧长64B
#### 网桥转发表自学习
MAC帧，MAC地址，六个字节
交换机
转发表自学习：记录收到数据的端口的源地址，否则全部端口转发

### 4 网络层
#### ip数据报
局域网内路由器转发时，ip地址不变，mac地址改变？
ip数据报放在MAC帧中传播
arp：ip转mac，全1广播
dhcp 分配ip地址
icmp 控制消息
局域网内路由器转发ip地址不变，mac地址随路由设备变化
NAT，把局域网内ip转化为全球ip（并包括端口）
mtu分片，标志（字段）一样，偏移量不同，64位为单位
生存时间TTL★：路由器转发时减1，为0则不再转发。初始发送为1时，相邻能收到1，不转发，经过0个路由。
IP分组的分片：标志最低位MF为1表示后面还有分片。标识相同，片偏移以8B为单位。总数据增加数据报首部。
icmp，阻塞信息

#### 子网划分
去掉主机号全0全1
A类0开头，主机号24位
C类110开头（两个1一个0），主机号8位
D类用于组播
主机号全1为广播，ip全1为子网内有限广播
子网掩码，求“与”得到网络号加子网号，前n位（写成/n）
主机号可以再子网划分

#### 路由表
表项：目的网络和子网掩码（用来匹配目的地址，逐项与然后比较），下一跳IP（可以为direct，空），路由器接口（转发的线路）
结合网络拓扑图
目的网络0.0.0.0/0作为默认路由
主机地址子网掩码255.255.255.255
路由聚合：下一跳一样的合并子网（取前缀，子网号变短）
最长匹配原则：匹配子网号最长的

#### 路由表更新
RIP
表项：目的，距离，下一跳
信息：发送方（必须相邻），目的，距离
距离为相邻的路由的信息再加1
RIP 协议，接受相邻路由的信息
+ 相同下一跳，更新替换
+ 新项目，添加
+ 不同下一跳，取短的下一跳
直接相邻的，直接更新
否则，有更小的路径，添加/替换为更小的

收到的信息，直接连接为1，16则不可达
转发时跳数加1
OSPF使用Dijkstra最短距离，自治系统
BGP协议 外部网关协议，网关之间
#### IP协议
     
#### 子网划分

### 5 传输层

#### TCP

TCP是可靠的（往底层都不可靠）
作为ip分组的数据
最小帧长46字节，否则填充
返回的ack为希望下一个收到的seq
seq按字节
#### TCP 连接
三次握手
1 SYN => 请求
2 SYN ACK <= 收到
3 ACK => 发送数据
ack=seq_对方+1
seq=ack
前两个有SYN
释放
1 FIN => 我结束了
2 ACK <= 收到
3 FIN ACK <= 我也结束了
4 ACK => 收到
其中2可以传输数据，seq在增大
相比建立，用FIN且多了第二步（同3方向一样）

#### 可靠传输、流量控制、拥塞控制
确认号是下一个要接受的
发送窗口（发送端）取接受窗口（接收端）、拥塞窗口（发送端）的小的
最大吞吐率=发送窗口/往返时延 ★
信道利用率=最大吞吐率/信道带宽
1Mb/s=10^3b/s，单位都用位bit表示

拥塞窗口的慢开始+拥塞避免
+ 超时时门限为窗口一半，窗口为1
+ 窗口加倍，直到到正好门限（发送1，1个rtt后变成2）
+ 转变成窗口加1
然后算发送窗口，考虑接受窗口剩余大小

补充：三个重复ACK，快重传，窗口减半而不是变成1
TCP可靠，udp不可靠


### 6 应用层
dns 域名转ip
web/http 头，用TCP收发
email 读pop3发送smtp
ftp 20数据 21控制

## 五 参考资料

专门指定教材
大纲解析的题目
王道论坛的指导书
考研统考真题
各个学校试题
leetcode
学校的ppt和期末试卷

用orgmode弄了大纲，之后以纯文本编辑
一些常规题型一定要手动算过。
不清楚的地方单独着重看。

补充，一些题统考真题没考过的，学校考过的。
crc
广义表
inode
非递归算法，
八皇后
求幂






